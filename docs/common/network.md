
# 概念

## 网络模型
<ImageView name='common1.png' alt="网络模型"></ImageView>
**OSI 七层模型**：

- **物理层**：负责在物理介质上传输原始的数据比特流，定义了传输介质的规格、电气特性、连接方式等。例如网线、光纤等的相关标准属于这一层。
- **数据链路层**：将原始的传输线路转变成无差错的数据链路，实现相邻节点之间可靠的数据传输。它包括了介质访问控制（MAC）子层和逻辑链路控制（LLC）子层，MAC 地址就是这一层的概念。
- **网络层**：主要任务是选择合适的路由和交换节点，将数据从源主机传输到目标主机。它的关键协议如 IP 协议。
- **传输层**：提供端到端的数据传输服务，确保数据可靠、顺序地到达目的地。常见的协议有 TCP 和 UDP。
- **会话层**：负责建立、维护和管理通信双方之间的会话。比如协调通信双方的交互过程。
- **表示层**：处理数据的表示形式，包括数据格式转换、加密解密、压缩与解压缩等。确保不同系统之间能够正确理解和处理数据。
- **应用层**：为用户提供直接的服务，如电子邮件、文件传输、网页浏览等。常见的应用层协议有 HTTP、FTP 等。

OSI 七层模型具有以下重要意义：

- 它提供了一个清晰的网络体系结构框架，有助于理解网络通信的各个层面和功能。
- 促进了不同厂商设备之间的互操作性和兼容性。
- 方便了网络协议的开发和设计，每个层次可以专注于特定的任务和功能。
- 为网络故障排查和性能优化提供了指导。

然而，在实际应用中，TCP/IP 模型更为广泛使用，但 OSI 七层模型在理论研究和教学等方面仍具有重要地位。
## 分层的意义

当遇到一个复杂问题的时候，可以使用分层的思想把问题简单化

比如，你有半杯82年的可乐，想分享给你的朋友王富贵，但你们已经10年没有联系了。要完成这件事，你可能要考虑：

- 我用什么装可乐？

  可能的方案：塑料瓶、玻璃瓶、煤气罐

- 怎么保证可乐始终处于低温？

  可能的方案：保温杯、小冰箱、冰盒

- 如何保证可乐不被运输的人偷喝？

  可能的方案：封条、在上面写「毒药」

- 如何获取王富贵的地址？

  可能的方案：报案失踪、联系私人侦探、联系物流公司的朋友
  
- 如何运输？

  可能的方案：自行车、汽车、火车、高铁、飞机、火箭

这就形成了一个分层结构

<ImageView name="common2.png" alt="分层"  />  

从常理出发，我们可以得出以下结论：

- 每层相对独立，只需解决自己的问题
- 每层无须考虑上层的交付，仅需把自己的结果交给下层即可
- 每层有多种方案可供选择，选择不同的方案不会对上下层造成影响
- 每一层会在上一层的基础上增加一些额外信息


## 数据的封装和解封装

![image-20211008163458168](http://mdrs.yuanjin.tech/img/20211008163458.png)

# 应用层协议

## URL

URL（Uniform Resource Locator）即统一资源定位符，它是一种用于标识互联网上资源的字符串。

URL 通常由以下几个部分组成：
<ImageView name='common3.png' alt="URL"/>

他表达了：

从网络中`哪台计算机(domain)`中的`哪个程序(port)`寻找`哪个服务(path)`,并注明了获取服务的`具体细节(query,hash)`,以及要用什么`协议(schema)`进行通信

- **协议(schema)**：用于指定使用哪种协议来访问该资源，例如 HTTP、HTTPS、FTP 等。
- **域名(domain)**：用于指定要访问的互联网服务器的地址，例如 www.baidu.com。
- **端口号(port)**：用于指定要访问的互联网服务器的端口号，默认为 80。
- **路径(path)**：用于指定要访问的互联网服务器的资源路径，例如 /index.html。
- **查询参数(query)**：用于指定要传递给互联网服务器的参数，例如 ?name=John&age=25。
- **哈希值(hash)**：用于指定页面内的特定位置，例如 #top。

当协议为HTTP时，端口号为80，当协议为HTTPS时，端口号为443。这两个协议的端口号可以省略；
`schema,domain,path` 这三者为必填项，其余为选填项。
URL 通常用于在互联网上定位和访问各种资源，例如网页、文件、服务等。

## 常见的应用层协议

- **HTTP**：用于在互联网上传输网页和数据，是互联网上最常用的应用层协议。
- **HTTPS**：是 HTTP 的安全版本，用于在互联网上传输敏感信息，例如信用卡号、密码等。
- **FTP**：用于在互联网上传输文件，是互联网上最常用的应用层协议之一。
- **SMTP**：用于在互联网上发送电子邮件，是互联网上最常用的应用层协议之一。

## HTTP

HTTP（HyperText Transfer Protocol）即超文本传输协议，是互联网上最常用的应用层协议之一。

HTTP 是一种基于请求-响应模式的、无状态的、应用层的协议。

### 传递消息模式
将发送请求一方称之为客户端(Client)，将接收请求的一方称之为服务器(Server)
<ImageView name="common4.png" alt="HTTP传递消息模式"  />  

HTTP 的消息格式是一种纯文本的格式，由以下几个部分组成：

- **起始行(start line)**：用于描述请求或响应的基本信息，例如请求方法、请求 URI、HTTP 版本等。
- **消息头(header)**：用于描述请求或响应的附加信息，例如用户代理、内容类型等。
- **空行**：用于分隔起始行和消息体。
- **消息体(body)**：用于传输请求或响应的数据。

比如以下一段请求报文,以vscode的rest client插件为例
::: code-group

```http:line-numbers [请求报文]
GET /j/search_tags?type=movie&tag=%E7%83%AD%E9%97%A8&source=index HTTP/1.1
Host: movie.douban.com


```
```http:line-numbers [响应报文]
HTTP/1.1 200 OK
Date: Tue, 18 Jun 2024 12:46:44 GMT
Content-Type: application/json; charset=utf-8
Transfer-Encoding: chunked
Connection: close
X-Xss-Protection: 1; mode=block
X-Douban-Mobileapp: 0
Expires: Sun, 1 Jan 2006 01:00:00 GMT
Pragma: no-cache
Cache-Control: must-revalidate, no-cache, private
Set-Cookie: ck="deleted"; max-age=0; domain=.douban.com; expires=Thu, 01-Jan-1970 00:00:00 GMT; path=/,dbcl2="deleted"; max-age=0; domain=.douban.com; expires=Thu, 01-Jan-1970 00:00:00 GMT; path=/
X-DAE-App: movie
X-DAE-Instance: default
Server: dae
Strict-Transport-Security: max-age=15552000
X-Content-Type-Options: nosniff
Content-Encoding: gzip

{
  "tags": [
    "热门",
    "最新",
    "豆瓣高分",
    "冷门佳片",
    "华语",
    "欧美",
    "韩国",
    "日本"
  ]
}

```
:::
请求体是不能省略的，只是因为该插件在发送请求时添加了换行符和请求体

### 请求（Request）
#### 请求方法

**请求方法是请求行中的第一个单词，它向服务器描述了客户端发出请求的动作类型。在 HTTP 协议中，不同的请求方法只是包含了不同的语义，但服务器和浏览器的一些约定俗成的行为造成了它们具体的区别**

<ImageView name="common5.png" alt="HTTP请求方法"  />  

```js
fetch('https://www.baidu.com', {
  method: 'heiheihei', // 告诉百度，我这次请求是来嘿嘿嘿的
});
```
上面的请求中，我们使用了自定义方法`heiheihei`。虽然百度服务器无法理解这样的请求是在干什么，但这样的请求也是可以正常发送到百度服务器的。

在实践中，客户端和服务器慢慢的形成了一个共识，约定俗成的规定了一些常见的请求方法：

- **GET**，表示向服务器获取资源。业务数据在请求行中，无须请求体
- **POST**，表示向服务器提交信息，通常用于产生新的数据，比如注册。业务数据在请求体中
- **PUT**，表示希望修改服务器的数据，通常用于修改。业务数据在请求体中
- **DELETE**，表示希望删除服务器的数据。业务数据在请求行中，无须请求体。
- **OPTIONS**，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交
- **TRACE**，回显服务器收到的请求，主要用于测试和诊断
- **CONNECT**，用于建立连接管道，通常在代理场景中使用，网页中很少用到

::: info GET 和 POST 的区别

**由于浏览器和服务器约定俗称的规则**，造成了 GET 和 POST 请求在 web 中的区别：

1. 浏览器在发送 GET 请求时，不会附带请求体
2. GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。
3. GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制
4. 大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中
5. 刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。
6. GET 请求的地址可以被保存为浏览器书签，POST 不可以
::: 

#### 请求头

**请求头是请求行之后的消息头，用于描述请求的附加信息。**

- **Host**：用于指定请求的服务器地址和端口号。
- **Origin**：用于指定请求的源地址,一般只存在于 [CORS 跨域请求](../browser/cross-cros.md)中，非跨域请求没有该请求头。。
- **User-Agent**：用于指定客户端的浏览器类型和版本。
- **Accept**：告知服务器客户端能够接受的内容类型，以 MIME 类型的形式表达，比如：`text/html`,`application/json`,`text/plain`,`image/*` 等，更多请参考[MIME 类型](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
- **Accept-Encoding**：可接受的编码方式，如 `gzip` 等压缩格式。
- **Authorization**：用于包含认证信息，如基本认证或令牌等。
- **[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)**：控制缓存策略，如 `no-cache` 表示不使用缓存。
- **Content-Length**：表示请求体的长度。
- **Content-Type**：说明请求体的媒体类型，如 `application/json` 表示 JSON 数据。
- **If-Modified-Since**：用于条件请求，如果自指定时间后资源未修改则返回 304 状态码。
- **If-None-Match**：类似 If-Modified-Since，根据资源的 ETag 进行条件请求。
- **Referer**：指示请求是从哪个页面链接过来的。
#### 请求体
请求体（Request Body）是在 HTTP 请求中用于承载要发送给服务器的具体数据的部分。

以下是关于请求体的一些要点：

**数据形式**：可以是各种格式的数据，比如表单数据（通常在 `application/x-www-form-urlencoded` 或 `multipart/form-data` 格式中）、JSON 数据（`application/json`）、XML 数据等。

**用途**：用于传递客户端需要提交给服务器的详细信息，比如提交表单时的字段值、发送特定的参数、上传文件等。

**存在情况**：并不是所有请求都有请求体，例如一些简单的 GET 请求通常没有请求体，而 POST、PUT 等请求常常包含请求体来携带重要数据。

**大小限制**：可能会受到服务器配置、网络等因素的限制。

请求体使得客户端能够向服务器发送更丰富、更具体的信息，以实现各种交互操作和数据传递需求。

### 响应（Response）
#### 响应行
响应行由[状态码](https://www.runoob.com/http/http-status-codes.html)和状态码的文本描述组成，它们位于响应报文的起始行中。

```txt
HTTP/1.1 200 OK
```

状态码是三位数字，用于表示请求的处理结果。
状态码的文本描述是状态码的英文解释，用于帮助用户理解状态码的含义。
HTTP 定义了以下几种状态码：

| 状态码 | 状态码的文本描述 |
| - | - |
|1xx|信息性状态码|
|2xx|成功状态码|
|3xx|重定向状态码|
|4xx|客户端错误状态码|
|5xx|服务器错误状态码|

#### 响应头
响应头是服务器返回给客户端的关于响应的一些元信息。以下是一些常见的响应头及其含义：

**Content-Type**：指示响应体的内容类型，如 `application/json`、`text/html` 等。

**Content-Length**：表示响应体的长度。

**Location**：用于重定向时指定新的资源位置。

**Set-Cookie**：设置客户端的 Cookie。

**Server**：告知客户端服务器的信息。

**Access-Control-Allow-Origin**：在跨域资源共享（CORS）中，指定允许访问该资源的源。

**Cache-Control**：控制缓存策略。

**Expires**：指定资源的过期时间。

**Last-Modified**：表示资源最后一次修改的时间。

**ETag**：资源的唯一标识。

[HTTP表头参考](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)

### HTTP各版本差异
HTTP 协议的不同版本包括 HTTP/1.0、HTTP/1.1 和 HTTP/2.0，每个版本都有一些特定的特性和改进，以下是它们的主要差异：
#### HTTP/1.0
  - **短连接**：每次请求/响应都需要建立一个新的 TCP 连接，完成后立即关闭连接， 连接的建立和销毁都会占用服务器和客户端的资源，造成内存资源和时间的浪费；
  - **队头阻塞**：下一个 HTTP 请求必须在前一个 HTTP 响应到达之前才能发送，如果前一个 HTTP 响应一直不到达，那么下一个 HTTP 请求就不发送；
  - **不支持断点续传**：如果客户端请求的资源特别大，服务器端发送这个资源的时间超出了客户端的超时时间，那么客户端就直接 close 这个 TCP 连接了；
#### HTTP/1.1
  - **长连接**：引入了持久连接，减少了连接建立和断开的开销，提高了性能；
  - **管道化技术**：在长连接的基础上，允许单个 TCP 连接可以发送多个请求和接收多个响应，解决了 HTTP/1.0 的队头阻塞问题，但带来了新的队头阻塞问题；如下图：
    - **服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容**。如果最先收到的请求的处理时间长，响应生成也慢，就会阻塞已经生成了的响应的发送。
    <ImageView name="common6.png" alt="HTTP/1.1 管道化技术"/>
    - 常见解决方案：
      1. 通过减少文件数量，从而减少队头阻塞的几率
      2. 通过开辟多个TCP连接，实现真正的、有缺陷的并行传输。浏览器会根据情况，为打开的页面自动开启TCP连接，对于`同一个域名`的连接最多6个，如果要突破这个限制，就需要把资源放到不同的域中
    现代浏览器一般时默认不开启管道化技术。
  - **新增方法**：PUT、PATCH、OPTIONS、DELETE；
  - **缓存控制**：引入了更强大和灵活的`缓存控制机制`，包括 `Cache-Control` 头部，可以通过指定缓存的有效期、是否可缓存、是否可被代理服务器缓存等属性来控制缓存行为,而HTTP1.0 只能通过 `Expires`进行简单的控制；
    - **Cache-Control 头部**：它提供了非常详细的缓存控制指令，如 `max-age` 可以明确指定资源在多少秒内有效可直接使用而无需再次请求；`no-cache` 表示需要先与服务器验证等。
    - **Expires 头部**：指定一个绝对时间，在此时间之前可以直接使用缓存。
    - **Last-Modified 和 If-Modified-Since 头部组合**：服务器发送资源时带上 `Last-Modified` 表示资源最后修改时间，客户端后续请求时通过 `If-Modified-Since` 带上上次收到的该值，服务器据此判断资源是否有更新。
    - **ETag 和 If-None-Match 头部组合**：服务器为资源生成一个`唯一标识（ETag）`，客户端请求时通过 `If-None-Match` 带上该值，服务器根据其来确定资源状态。这些机制使得缓存的管理更加灵活和准确，能够更好地适应不同场景下对缓存的需求。
  - **错误处理**：引入了更多的状态码，以更精确地表示请求过程中的不同状态，例如 100 Continue、206 Partial Content 等；
#### HTTP/2.0
  - **二进制分帧层**：HTTP/2中的二进制分帧是该协议的一项重要特性，**它在应用层（HTTP/2）和传输层（TCP 或 UDP）之间增加了一个二进制分帧层**。这是 HTTP/2中最大的改变，也是其性能比 HTTP/1.1有大幅提高的重要原因之一
    <ImageView name="common7.png" alt="HTTP/2 二进制分帧层" align='center'/>
    - 在二进制分帧层中，HTTP/2将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。这一特性使得 HTTP/2在处理请求和响应时更加高效。具体而言，HTTP/2中的帧包含以下部分：
      - **类型**：帧的类型，如 DATA、HEADERS、PRIORITY 等。
      - **长度**：帧的长度。
      - **标记**：帧的标记。
      - **流标识**：用于标识帧所属的流。
      - **帧有效载荷**：帧所携带的数据。
  - **多路复用**：可以在单个 TCP 连接上同时发送多个请求和接收多个响应，实现了请求/响应的并行传输，提高了性能；
  - **头部压缩**：使用 HPACK 算法对请求/响应头部进行压缩，减小了头部的大小，降低了通信开销；
  - **服务器推送**：允许服务器主动向客户端推送资源，当客户端请求某个资源时，服务器可以预测客户端需要的其他资源并主动推送给客户端，提高了页面加载速度；
  - **流量控制和优先级**：支持流量控制和优先级控制，可以根据资源的重要性和紧急程度进行有效的调度和分配，提高了网络的利用率和性能；
  - **单连接并发数限制**：中的多路复用机制可以在单个 TCP 连接上同时处理多个请求/响应，减少了 TCP 连接的数量，降低了服务器和客户端的负载。

